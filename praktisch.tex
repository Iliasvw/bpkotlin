\chapter{Praktische uitwerking Kotlin/Native}
\label{ch:praktisch}
In dit hoofdstuk zal er praktisch een Kotlin/Native project worden gebouwd. De bedoeling is om aan de hand van een voorbeeld de volledige werking uit te leggen. In dit voorbeeld zal er een simpele applicatie gebouwd worden waarbij gebruikers een shopping cart kunnen aanmaken, producten kunnen bekijken en toevoegen aan de shopping cart en kunnen afrekenen. Het volledige project is te vinden op 
https://github.com/Iliasvw/kotlin-native-example.

\section{Domeinmodel}
Aangezien het doel van Kotlin/Native het delen van business logica is, is het handig om op voorhand na te denken over het domeinmodel. Welke klassen heb ik nodig, welke attributen en methodes moeten deze klassen hebben. Een domeinmodel geeft je ook een duidelijk overzicht over je applicatie. Zie figuur \ref{fig:domeinmodel-kn} om het domeinmodel te zien van deze voorbeeldapplicatie.

\begin{figure} [ht]
	\centering
	\includegraphics[width=0.95\textwidth]{img/domeinmodel.png}
	\caption{Klassendiagram domeinlogica}
	\label{fig:domeinmodel-kn}
\end{figure}

\section{Requirements}
Om gebruik te kunnen maken van Kotlin/Native voor het ontwikkelen van cross-platform applicaties (iOS \& Android), zijn er enkele vereisten:
\begin{itemize}
	\item \textbf{Android studio} voor het ontwikkelen van de Android applicatie.
	\item \textbf{Xcode} voor het ontwikkelen van de iOS applicatie (toestel met MacOS is vereist).
	\item \textbf{IntelliJ IDEA} (optioneel) voor het opzetten van het project. Dit kan eventueel met een andere IDEA die gradle projecten ondersteunt, worden opgezet.
	\item \textbf{Gradle} om gebruik te kunnen maken van de Kotlin/Native compiler en plugin. Deze wordt geïnstalleerd bij het instellen van IntelliJ IDEA of Android Studio.
\end{itemize}

\section{Stap 1: project initiatie}
De eerste stap in het ontwikkelen van een Kotlin/Native project is het maken van een nieuwe map, op een gewenste locatie op de harde schijf van je computer. Hierin zal er een eerste bestand worden aangemaakt: \textbf{build.gradle}.

\begin{lstlisting}
subprojects {
 buildscript {
  ext.kotlin_version = '1.2.31'
  ext.kotlin_native_version = '0.6.2'
		
  repositories {
   jcenter()
   google()
   maven { url "http://kotlin.bintray.com/kotlinx" }
   maven { url "https://plugins.gradle.org/m2/" }
   maven { url "https://dl.bintray.com/jetbrains/ kotlin-native-dependencies" }
  }

  dependencies {
   classpath "org.jetbrains.kotlin:kotlin-gradle-plugin: $kotlin_version"
   classpath 'com.android.tools.build:gradle:3.0.1'
   classpath "org.jetbrains.kotlin:kotlin-native-gradle-plugin: $kotlin_native_version"
  }
 }
	
 group 'ilias.vw'
 version '1.0-SNAPSHOT'
	
 repositories {
  jcenter()
  maven { url "http://kotlin.bintray.com/kotlinx" }
 }
	
 tasks.withType(Test) {
  testLogging {
   showStandardStreams = true
   events "passed", "failed"
  }
 }
}
\end{lstlisting}
\subsection{Versies}
Bovenaan geven we aan welke versie van Kotlin en Kotlin/Native we willen gebruiken. Dit zijn beide de nieuwste versies. Opgelet, het is niet altijd vanzelfsprekend om de laatste versie van Kotlin/Native te gebruiken. Er wordt voortdurend gewerkt aan Kotlin/Native en nieuwe dingen worden continu gepushed op de Github repository. Het kan al eens gebeuren dat sommige features niet altijd even goed werken, waardoor de applicatie soms niet werkt. Bij twijfels, neem een minder recente versie van de Kotlin/Native plugin.

\subsection{Repositories}
In de repositories tag worden de juiste repositories gelinkt:
\begin{itemize}
	\item \textbf{Kotlinx} bevat alle coroutines\footnote{Programmaonderdelen die asynchroon programmeren vergemakkelijken door gecompliceerde logica in bibliotheken te steken} die Kotlin kan gebruiken.
	\item \textbf{Gradle}
	\item \textbf{Kotlin-native-dependencies} stelt alle dependencies die Kotlin/Native nodig heeft ter beschikking.
\end{itemize}

\subsection{Dependencies}
In de dependencies tag worden de juiste dependencies gelinkt:
\begin{itemize}
	\item \textbf{Kotlin-gradle} laadt de Kotlin-gradle plugin met de versie van Kotlin die wordt aangegeven bovenaan het build script.
	\item \textbf{Android build tools} is nodig voor het bouwen van de Android applicatie.
	\item \textbf{Kotlin-native-gradle-plugin} is de Kotlin/Native plugin die gebruikt zal worden om te zorgen voor een cross-platforme applicatie.
\end{itemize}

\subsection{Overige informatie}
\label{sec:overige}
\begin{itemize}
	\item \textbf{Group} stelt het groupId van het project in.
	\item \textbf{Version} geeft de versie van het project weer.
	\item \textbf{testLogging} wordt gebruikt voor het uitvoeren van de testen.
\end{itemize}

\section{Stap 2: project structuur}
Nadat het build.gradle bestand gemaakt is, is het de bedoeling om via IntelliJ IDEA het gradle bestand te importeren. Zie figuur \ref{fig:stap2-import}. IntelliJ zal een dialoogvenster openen, waarbij het build.gradle bestand moet worden geopend. De IDE zal hierna het build.gradle bestand uitvoeren en het genereert enkele bestanden.

\begin{figure} [ht]
	\centering
	\includegraphics[width=0.60\textwidth]{img/stap2-import.png}
	\caption{Importeren van een project}
	\label{fig:stap2-import}
\end{figure}

In de huidige versie van Kotlin/Native worden de overige mappen nog niet automatisch aangemaakt. Alle andere mappen, die te zien zijn in figuur \ref{fig:knstructuur} moeten handmatig aangemaakt worden. Deze mappenstructuur zal geleidelijk aan opgebouwd worden naargelang de stappen vorderen.

\section{Stap 3: Common map }
In de common map wordt alle gemeenschappelijke code aangemaakt. In deze map moet er aan een bepaalde structuur worden voldaan, zie figuur \ref{fig:stap3-common}.

\begin{figure} [ht]
	\centering
	\includegraphics[width=0.60\textwidth]{img/stap3-common.png}
	\caption{Common module structuur}
	\label{fig:stap3-common}
\end{figure}

\subsection{Build map}
De build map bevat alle gecompileerde bestanden die genereerd worden door Kotlin/Native. Deze bestanden worden aangemaakt bij iedere gradle run en/of build.

\subsection{Main en test map}
\label{sec:maintestcommon}
Zoals te zien is op figuur \ref{fig:stap3-common} heeft zowel de main als test map enkele subpackages. Deze beginnen met de groupId die ingesteld is in sectie \ref{sec:overige} met daarin nog eens een 'libs' map. De naam van deze 'libs' map is vrij te kiezen.

De main map zal alle gemeenschappelijke klassen bevatten (expect en gewone klassen, zie sectie \ref{sec:expectandactual}).

De test map zal alle gemeenschappelijke test klassen bevatten, gebruikmakend van de klassen in de main map.

\subsection{Build.gradle}
Natuurlijk moet de common module ook gecompileerd worden door Kotlin/Native. Hiervoor is er een build.gradle nodig.

\begin{lstlisting}
apply plugin: 'kotlin-platform-common'

sourceSets {
 main.kotlin.srcDirs += 'main/'
 test.kotlin.srcDirs += 'test/'
}

dependencies {
 compile "org.jetbrains.kotlin:kotlin-stdlib-common:$kotlin_version"
 testCompile "org.jetbrains.kotlin:kotlin-test-annotations-common: $kotlin_version"
 testCompile "org.jetbrains.kotlin:kotlin-test-common:$kotlin_version"
}
\end{lstlisting}
De bovenste regel in de build.gradle geeft aan dat we gebruik maken van de kotlin-platform-common plugin. Deze zal verantwoordelijk zijn voor het compileren en delen van alle gemeenschappelijke code over de verschillende platformen.

Er worden ook twee sourceSets toegevoegd. SourceSets vertegenwoordigen een logische groep van Java en/of bronnen en middelen.

Tenslotte worden er drie dependencies toegevoegd. De stdlib is verantwoordelijk voor het aanmaken van de Kotlin Standard Library. Er worden nog twee test dependencies toegevoegd, één verantwoordelijk voor de annotations, de andere voor het opstellen en uitvoeren van de testen (later meer over testen).

\section{Common code}
\subsection{Cart}
\begin{lstlisting}
package ilias.vw.libs
	
class Cart constructor(name: String) {
 var name: String = name
 private var cartLines: List<CartLine> = mutableListOf()
	
 fun getCartLines(): List<CartLine> {
  return this.cartLines
 }
	
 fun addCartLine(cartLine: CartLine) {
  for (item in cartLines) {
   if (item.getProduct().getName() == cartLine.getProduct().getName()) {
    item.add(cartLine.getQuantity())
    return
   }
  }
  this.cartLines += cartLine
 }
	
 fun getTotalPrice(): Double {
  var totalPrice = 0.0
	
  for (line in cartLines) {
   totalPrice += line.getTotalPrice()
  }
	
  return totalPrice
 }
	
 fun removeCartLine(cartLine: CartLine) {
  this.cartLines -= cartLine
 }
}
\end{lstlisting}

\subsection{CartLine}
\begin{lstlisting}
package ilias.vw.libs

class CartLine {
 private val product: Product
 private val quantity: Int

 constructor(product: Product, quantity: Int) {
  this.product = product
  this.quantity = quantity
 }

 fun getProduct(): Product {
  return this.product
 }

 fun getQuantity(): Int {
  return this.quantity
 }

 fun getTotalPrice(): Double {
  return product.getPrice() * quantity
 }
}
\end{lstlisting}

\subsection{Product}
\begin{lstlisting}
package ilias.vw.libs

expect class Product(name: String, price: Double, 
	description: String, productImage: Int) {
 fun getName(): String
 fun getPrice(): Double
 fun getDescription(): String
 fun getProductImage(): Int
}
\end{lstlisting}

\section{Stap 4: platforms folder}
De platform folder bevat enkele subfolders, één subfolder per platform waarvoor men wenst te ontwikkelen. Bij dit voorbeeld zullen er dus twee subfolders aanwezig zijn, namelijk Android en iOS. Zie figuur \ref{fig:stap4-structuur}.

\begin{figure} [ht]
	\centering
	\includegraphics[width=0.60\textwidth]{img/stap4-structuur.png}
	\caption{Platforms module structuur}
	\label{fig:stap4-structuur}
\end{figure}

Per submap, hebben we opnieuw twee submappen, namelijk main en test. Net zoals bij de common map. 

Zowel de main en test bevatten elk nog een map. Bij Android is dit een package die begint met het groupId, zie sectie \ref{sec:overige}, en eindigt met een willekeurige naam. In dit voorbeeld is dit 'libs'. Dit dient identiek te zijn met de naam van de package gekozen in de common map, zie sectie \ref{sec:maintestcommon}. In het geval van iOS zijn dit geen packages maar eerder een mappenstructuur.

\subsection{android map}
Platformspecifieke code voor Android.
\begin{lstlisting}
package ilias.vw.libs

import java.io.Serializable

actual class Product: Serializable {
 private val name: String
 private val price: Double
 private val description: String
 private val productImage: Int

 actual constructor(name: String, price: Double, 
 	description: String, productImage: Int) {
  this.name = name;
  this.price = price
  this.description = description
  this.productImage = productImage
}

 actual fun getName(): String {
  return "Android: " + this.name
 }

 actual fun getPrice(): Double {
  return this.price
 }

 actual fun getDescription(): String {
  return this.description
 }

 actual fun getProductImage(): Int {
  return this.productImage
 }
}
\end{lstlisting}

\subsubsection{Build.gradle}
\begin{lstlisting}
apply plugin: 'kotlin-platform-jvm'

repositories {
 jcenter()
 maven { url "http://kotlin.bintray.com/kotlinx" }
}

sourceSets {
 main.kotlin.srcDirs += 'main/'
 test.kotlin.srcDirs += 'test/'
}

dependencies {
 compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
 expectedBy project(":common")

 testCompile "junit:junit:4.12"
 testCompile "org.jetbrains.kotlin:kotlin-test-junit: $kotlin_version"
 testCompile "org.jetbrains.kotlin:kotlin-test:$kotlin_version"
}
\end{lstlisting}

In deze build.gradle wordt er gebruik gemaakt van de kotlin-platform-jvm plugin. Android applicaties maken nog steeds gebruik van de JVM en dus ook deze android applicatie. 

De sourceSets worden ingesteld. Kotlin/Native zal steeds zoeken naar code in de map src/kotlin/main of src/kotlin/test, maar hier geven we aan dat code te vinden is in de main en test map en dus niet onder een src/kotlin map.

Tenslotte worden alle dependecies geladen en wordt er aangegeven dat we een common module verwachten die code bevat.

\subsubsection{Platformspecifieke code}
Platformspecifieke code voor iOS.
\begin{lstlisting}
package ilias.vw.libs

actual class Product {
 private val name: String
 private val price: Double
 private val description: String

 actual constructor(name: String, price: Double, 
 	description: String) {
  this.name = name;
  this.price = price
  this.description = description
 }

 actual fun getName(): String {
  return "iOS: " + this.name
 }

 actual fun getPrice(): Double {
  return this.price
 }

 actual fun getDescription(): String {
  return this.description
 }
}
\end{lstlisting}

\subsection{ios map}
In deze map komt alle iOS-specifieke code terecht.

\subsubsection{Build.gradle}
\label{sec:ios-build-gradle}
\begin{lstlisting}
apply plugin: 'konan'

konanArtifacts {
 framework('SharediOS', targets: ['iphone', 'iphone_sim']){
  enableDebug true
  enableMultiplatform true

  srcDir 'main'
 }

 library('test-library') {
  enableMultiplatform true
  srcDir 'main'
 }

 program('shared-ios-test') {
  srcDir 'test'
  commonSourceSet 'test'
  extraOpts '-tr'
  libraries {
   artifact 'test-library'
  }
 }
}

dependencies {
 expectedBy project(':common')
}
\end{lstlisting}

Zoals reeds te lezen is in sectie \ref{sec:use-ios-code} zal Kotlin/Native alle Kotlin code compileren naar een iOS framework. In de build.gradle wordt de naam van het framework en de toestellen (iPhone en iPhone simulators) dat men wenst te ondersteunen ingesteld.

De main map wordt als source directory ingesteld. Om ervoor te zorgen dat op iOS ook de testen kunnen worden uitgevoerd, wordt de main map ingesteld als bron die alle Kotlin klassen bevat, de test map wordt ingesteld als bron waar alle testen zijn te vinden.

Tenslotte wordt er opnieuw aangegeven dat we een common module verwachten die code bevat.

\subsubsection{Platformspecifieke code}
%TODO: Code toevoegen%

\section{Stap 5: Android map}
In de android map is het de bedoeling om via Android Studio een nieuw project aan te maken. Bij het aanmaken van het project in Android Studio kan je de locatie van het project opgeven. Deze locatie moet zodanig ingesteld zijn dat het Android project een submap is van het Kotlin/Native project en waardoor het geïntegreerd zal worden in dit project.

\subsection{settings.gradle}
Voor we gebruik kunnen maken van de Kotlin klassen, moeten er eerst nog enkele wijzigingen gebeuren in de settings.gradle. De settings.gradle wordt vervangen door onderstaande code:

\begin{lstlisting}
include ':app'

include ':common'
project(":common").projectDir = new File("../common")

include ':platforms-android'
project(":platforms-android").projectDir = new File("../platforms/android")
\end{lstlisting}

Via de settings.gradle wordt er aangegeven om de common en platforms-android modules te includen in het project.

\subsection{build.gradle}
Tenslotte moet er nog een kleine wijziging doorgevoerd worden in de build.gradle van de app map. In de dependencies tag moet er enkele en alleen volgende lijn toegevoegd worden in de dependencies tag:

\begin{lstlisting}
implementation project(':platforms-android')
\end{lstlisting}

Hiermee wordt er aangegeven dat de android-specifieke implementatie te vinden is in platforms-android, waarvan de locatie is opgegeven in de settings.gradle. 

\section{Stap 6: iOS map}
Net zoals bij de android map, is het de bedoeling om via Xcode een nieuw Xcode project aan te maken dat ook een submap is van het Kotlin/Native project. Men kan zowel kiezen voor een Objective-C als Swift project aangezien het gecompileerde iOS framework zowel in beide projecten kan gebruikt worden.

\subsection{Gebruiken van het SharediOS framework}
Vooraleer men in Xcode kan gebruik maken van het SharediOS framework, moeten er een aantal dingen aangepast worden in de build phases van het project. Uit figuur \ref{fig:stap6-phases} kan worden afgeleid dat de build phases zijn aangepast. Volgende build phase moet worden toegevoegd: Compile Kotlin Native to iOS framework.
\begin{figure} [ht]
	\centering
	\includegraphics[width=0.75\textwidth]{img/stap6-phases.png}
	\caption{iOS build phases}
	\label{fig:stap6-phases}
\end{figure}

In deze nieuwe build phase moet er een script, afkomstig van \textcite{AlbertGao}, worden toegevoegd: 
\begin{lstlisting}
case "$PLATFORM_NAME" in
iphoneos)
NAME=iphone
;;
iphonesimulator)
NAME=iphone_sim
;;
*)
echo "Unknown platform: $PLATFORN_NAME"
exit 1
;;
esac

"$SRCROOT/../gradlew" -p "$SRCROOT/../platforms/ios" "build"
rm -rf "$SRCROOT/build/"
mkdir "$SRCROOT/build/"
cp -a "$SRCROOT/../platforms/ios/build/konan/bin/$NAME/" "$SRCROOT/build/"
\end{lstlisting}

Bij iedere gradle build van het Kotlin/Native project zal de build.gradle in de platforms/ios map ervoor zorgen dat de Kotlin code omgezet wordt naar een iOS framework. Dit framework vindt men terug in een submap van een build map. Zie figuur \ref{fig:stap6-build}. Er wordt dus zowel voor een echt toestel (iphone map) als voor een simulator (iphone\char`_sim map) een framework gegenereerd. Dit wordt gedaan omdat beiden op verschillende architecturen worden uitgevoerd.

\begin{figure} [ht]
	\centering
	\includegraphics[width=0.60\textwidth]{img/stap6-build.png}
	\caption{iOS build map}
	\label{fig:stap6-build}
\end{figure}

In bovenstaand build phase script wordt gekeken welk type toestel er wordt gebruikt, een echte iPhone of een simulator. Daarna zal het juiste framework gekopieerd worden naar de build folder in de iOS map. Waardoor bij iedere build en/of run van het Xcode project het laatst gegenereerde framework zal worden gebruikt en gekopieerd.

Tenslotte zal het framework nog in de build phases 'Link Binary With Libraries' en 'Embed Frameworks' moeten worden toegevoegd. Hierbij wordt er gelinkt naar het gekopieerde framework in de build folder.

\section{Aanspreken van code}
\subsection{Android}
Om gebruik te kunnen maken van de Kotlin code in de Android activities moet men simpelweg volgende import toevoegen om alle klassen te kunnen gebruiken: 

\begin{lstlisting}
import ilias.vw.libs.*
\end{lstlisting}

\subsection{iOS}
Om gebruik te kunnen maken van het SharediOS framework in de ViewControllers moet het framework worden geimporteerd door bovenaan in de ViewController volgende lijn toe te voegen:

\begin{lstlisting}
import SharediOS
\end{lstlisting}

Het aanmaken van een object in iOS is nu heel simpel geworden. Zoals te zien is in onderstaande code heeft Kotlin/Native een prefix gegeven aan de klassen. Kotlin/Native zal steeds de hoofdletters uit de naam van het framework filteren, dat gekozen wordt in de build.gradle van de iOS folder, zie sectie \ref{sec:ios-build-gradle}. Stel dat het framework KotlinNativeFramework heet, dan zal de prefix KNF zijn en zal de product klasse KNFProduct heten.

\begin{lstlisting}
var product: SOSProduct = SOSProduct(name: "Test")
\end{lstlisting}

\section{User interfaces}
De user interface moet dus per platform opgebouwd worden. Er is geen manier om één user interface te ontwikkelen voor beide platformen zoals bijvoorbeeld bij React/Native of Ionic. Dit kan zowel positief als negatief zijn. Het vraagt dubbel zoveel werk maar het geeft wel de mogelijkheid om verschillende accenten te leggen in de user interface per platform.

\section{Optioneel: testen}
Een essentieel deel van object-oriented programming is het testen van je code. In het Kotlin/Native framework is het mogelijk om je aangemaakte klassen te testen. Zo is er de mogelijkheid om in de common map en per platform een test map toe te voegen. Een voorbeeld van een testklasse:

\begin{lstlisting}
package ilias.vw.libs

import kotlin.test.*

class TestSampleCommon {
 @Test
 fun testCheckChartName() {
  val sample = Cart("test")
  val name = sample.name
  assertEquals(name, "test")
 }
}

\end{lstlisting}

Hierbij wordt er een cart aangemaakt met een naam 'test'. Daarna wordt de naam terug opgevraagd en wordt er gekeken of de naam die we initieel hebben meegegeven effectief gelijk is aan 'test'.